# Use Java 17 for Flink jobs

## Context

We are standardizing the JDK level for Apache Flink workloads that target Flink 2.0 and newer. We require:

* Compatibility with upstream Flink distributions, connectors, and tooling that now compile and test against Java 17 as their baseline.
* Long-term supported (LTS) JDK releases with security fixes available through 2029 without extra vendor contracts.
* Modern language/runtime features (records, sealed types, pattern matching, virtual threads experimentation) that simplify POJOs and operator logic.
* Improved GC and GC logging defaults (G1/ZGC, CDS sharing, elastic metaspace) to keep long-running streaming jobs predictable under higher heap pressures.
* Consistent behavior between developer laptops, CI pipelines, and container images used in production clusters.

## Decision

Adopt **Java 17** as the minimum (and default) JDK for compiling, testing, packaging, and running all Flink >= 2.0 jobs.

## Consequences

**Pros:**

* **Upstream alignment:** Flink 2.0 dropped Java 11 support, so running on Java 17 keeps us on the supported matrix for the core runtime, connectors, and Table/SQL modules.
* **Language expressiveness:** Records, pattern matching for switch, sealed hierarchies, and text blocks reduce boilerplate around event schemas, configs, and SQL templates.
* **Operational safety:** Java 17 receives quarterly CPU updates through 2029, giving us a predictable patch cadence without paying for extended support.
* **Runtime improvements:** Enhanced G1/ZGC behavior, elastic metaspace, and JFR event stream upgrades ease tuning for long-lived streaming jobs under fluctuating throughput.
* **Tooling consistency:** CI agents, container images, and developer setups converge on a single JDK, simplifying shading, reproducible builds, and bytecode targeting.

**Cons:**

* **Migration effort:** Existing build containers, CI images, and shared libraries pinned to Java 11 must be upgraded or deprecated before adopting Flink 2.0.
* **Third-party laggards:** A handful of closed-source connectors or JDBC drivers may still ship only Java 11 bytecode; these need vendor updates or relocation into isolated services.
* **Local resource usage:** Developers on older laptops may need to install a new JDK and re-tune IDE heap settings.

## Alternatives considered

1. **Stay on Java 11**

   * **Pros:** No immediate upgrade effort for legacy pipelines; stable tooling.
   * **Cons:** Unsupported by Flink >= 2.0, misses security fixes post-2027 without paid support, and blocks use of modern language/runtime features.

2. **Jump directly to Java 21**

   * **Pros:** Latest LTS with even longer support window and more JVM features (e.g., virtual threads GA).
   * **Cons:** Flink 2.0 does not yet certify Java 21, some shading plugins and connectors still target 17 bytecode, and we would become upstream's regression canary.

3. **Support multiple JDK baselines**

   * **Pros:** Lets teams move at their own pace.
   * **Cons:** Doubles CI/CD complexity, increases container sprawl, and obscures which jobs are safe to run on Flink 2.x. We would still need Java 17 for the new runtime, so dual support adds cost without tangible benefit.
